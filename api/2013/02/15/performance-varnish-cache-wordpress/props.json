{
  "dateUnix": 1360946898000,
  "dateFormatted": "Friday 15 Feb 2013",
  "pageHeading": "Performance, Varnish Cache, WordPress",
  "pagePath": "/2013/02/15/performance-varnish-cache-wordpress/",
  "innerHTML": "<p>When it comes to website performance there’s a lot we can do.</p>\n<p>As designers it means finding a style that suits the Web as a medium; taking advantage of CSS, avoiding heavy raster graphics, etc etc. As front-end developers, well, <a href=\"http://csswizardry.com/2013/01/front-end-performance-for-web-designers-and-front-end-developers/\">Harry Roberts’</a> has a great round-up of techniques.</p>\n<p>There’s only so much we can do client-side. It’s always a trade off. It all goes downhill after <code>&lt;!DOCTYPE html&gt;</code>. I like Mark Perkins’ idea of a <a href=\"http://clearleft.com/thinks/responsivedesignonabudget/\">responsive budget</a>.</p>\n<h2 id=\"before-the-browser\">Before the browser</h2>\n<p>What many people in my position forget are the bottlenecks that exist server-side and across the Internet at large. Not much point minifying CSS if you’re sharing some backwater server with a hundred others for five bucks a month.</p>\n<p>A while ago I moved hosting to <a href=\"http://www.heartinternet.co.uk/vps/\">Heart Internet VPS</a>. (Before they started sponsoring my blog </disclaimer>.) Media Temple’s Grid hosting was terrible, but this was as much a move to consolidate my hosting and domains (away from GoDaddy).</p>\n<p>With a new virtual server to play with I installed <a href=\"https://www.varnish-cache.org/\">Varnish Cache</a>. Varnish sits in front of the web server and takes over port 80. That means when you hit a page on my site you’re served pre-rendered HTML and cached assets by Varnish. You never normally reach the “AMP” part of the LAMP stack (Apache, MySQL, and PHP).</p>\n<p>Here’s a wonderful illustration from <a href=\"http://en.wikipedia.org/wiki/File:Reverse_proxy_h2g2bob.svg\">Wiki Commons</a>:</p>\n<p class=\"b-post__image\"><img src=\"/images/2013/02/Reverse_proxy_h2g2bob.svg\" alt=\"Reverse_proxy_h2g2bob\"></p>\n\n<p>Setting up Varnish required some hacking of Plesk and Apache. I went at it like a lumberjack. In my wisdom I made no record of what I did and I was drinking heavily. That means any day now I might have to hit the <em>“restore factory settings</em>“ button.</p>\n<p>Until that day comes, my website is lightning fast.</p>\n<p>What I do know is blogged below for future reference:</p>\n<h2 id=\"varnish-and-wordpress\">Varnish and WordPress</h2>\n<p>Varnish isn’t plug-and-play. It comes with its own <a href=\"https://www.varnish-cache.org/docs/3.0/reference/vcl.html\">configuration language</a>. This config file tells Varnish how to handle all requests and caching. To make Varnish play nicely with WordPress I borrowed heavily from <a href=\"http://ocaoimh.ie/2011/08/09/speed-up-wordpress-with-apache-and-varnish/\">Donncha O Caoimh’s</a> work.</p>\n<p>Basically you want to avoid caching the admin area and requests where a user has comments pending. I messed that part up. You may have noticed last year that comments in the moderation queue on my blog were visible to the whole world. Useful.</p>\n<p>It’s also worth pointing out that you cannot clear cached CSS no matter how hard you hit ⌘R — but then you shouldn’t be making live edits via FTP anyway…</p>\n<h2 id=\"a-big-refresh\">A big refresh</h2>\n<p>My <a href=\"https://dbushell.com/2013/02/04/a-new-home/\">new site design</a> has a <em>“From the blog…”</em> feature in the page footer. This caused me some concern because dynamic content and caching don’t go hand in hand.</p>\n<p class=\"b-post__image\"><img src=\"/images/2013/02/from-the-blog.png\" alt=\"latest articles on dbushell.com\"></p>\n\n<p>In WordPress you would normally create a template include like so:</p>\n<pre><code class=\"language-php\">&lt;?php\n// include &quot;From the blog...&quot; section\nget_template_part(&#39;blog.partial&#39;);\n?&gt;\n</code></pre>\n<p>Naming conventions aside, this is WordPress/PHP basics. But a big problem arises when I publish a new article. This include is on every page. Do I purge my entire website? That would mean every page has to be re-cached. It would be beneficial if I can purge this area alone. That’s what <a href=\"https://www.varnish-cache.org/trac/wiki/ESIfeatures\">edge side includes</a> allow.</p>\n<p>On my production server the code above is replaced with:</p>\n<pre><code class=\"language-markup\">&lt;esi:include src=&quot;&lt;?php bloginfo(&#39;template_url&#39;); ?&gt;/blog.esi.php&quot;/&gt;\n</code></pre>\n<p>It’s not quite that simple. Varnish needs a URL to hit to access this document fragment. If you were to try and access any PHP file in the WordPress theme directory it would likely throw an error. <a href=\"http://timbroder.com/2012/12/getting-started-with-varnish-edge-side-includes-and-wordpress.html\">Tim Broder</a> provides the answer:</p>\n<pre><code class=\"language-php\">&lt;?php\n$cwd = getcwd();\n$path = substr($cwd,0,strpos($cwd,&#39;wp-content/&#39;));\nrequire($path . &#39;wp-blog-header.php&#39;);\n?&gt;\n</code></pre>\n<p>This ensures my latest posts <a href=\"http://codex.wordpress.org/Class_Reference/WP_Query\">WP_Query</a> can run when the template include is accessed independently of the theme. The next step is to let Varnish know when to clear the cache for certain URLs.</p>\n<h2 id=\"clearing-the-cache\">Clearing the cache</h2>\n<p>In my WordPress theme <code>function.php</code> I have:</p>\n<pre><code class=\"language-php\">function mytheme_purge_url($url)\n{\n    $c = curl_init($url);\n    curl_setopt($c, CURLOPT_CUSTOMREQUEST, &#39;PURGE&#39;);\n    curl_exec($c);\n    curl_close($c);\n}\n</code></pre>\n<p>Using cURL my blog can send a PURGE request to Varnish and clear the cache for a specific URL. From here it’s just a matter of hooking into the right admin actions:</p>\n<pre><code class=\"language-php\">add_action(&#39;save_post&#39;, &#39;mytheme_purge_post_cache&#39;);\nadd_action(&#39;deleted_post&#39;, &#39;mytheme_purge_post_cache&#39;);\n\nfunction mytheme_purge_post_cache($post_ID)\n{\n    $url = get_permalink($post_ID);\n    if ($url) {\n        mytheme_purge_url($url);\n        mytheme_purge_url(site_url(&#39;/blog/&#39;));\n        mytheme_purge_url(bloginfo(&#39;template_url&#39;) . &#39;/blog.esi.php&#39;);\n    }\n}\n</code></pre>\n<p>Remember that Varnish needs to be configured to never cache the WordPress admin area (otherwise you’ll never get past the login form). Now, after I save or delete a post the URLs for that post, the <a href=\"/blog/\">blog index</a>, and the <em>“From the blog…”</em> include are all purged. They are then cached again on the next request.</p>\n<p>So there it is. Probably the biggest speed boost I’ve given my website. I apologise that my technical ineptitude means I haven’t been able to write a full tutorial but I hope this proves useful to someone.</p>\n<p>Maybe my future self.</p>\n",
  "pageExcerpt": "When it comes to website performance there’s a lot we can do.\nAs designers it means finding a style that suits the Web as a medium; taking advantage of CSS, avoiding heavy raster graphics, etc etc. As front-end developers, well, Harry Roberts’ has a great round-up of techniques.\nThere’s only so much we can do client-side. It’s […]",
  "pageTitle": "Performance, Varnish Cache, WordPress – David Bushell – Web Design (UK)"
}