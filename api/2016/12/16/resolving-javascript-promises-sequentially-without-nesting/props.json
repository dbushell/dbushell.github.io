{
  "dateUnix": 1481882400000,
  "dateFormatted": "Friday 16 Dec 2016",
  "pageHeading": "Working with Promises",
  "pagePath": "/2016/12/16/resolving-javascript-promises-sequentially-without-nesting/",
  "innerHTML": "<p>JavaScript <a href=\"https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Promise\">promises</a> are a handy way to write asynchronous code. It’s common to have multiple promises resolve in parallel or series.</p>\n<p>Let’s say you have several functions that return a promise:</p>\n<pre><code class=\"language-javascript\">function act1() {\n  return new Promise((resolve, reject) =&gt; {\n    // do something that might reject...\n    resolve();\n  });\n}\n</code></pre>\n<p>It’s easy to run these functions in parallel:</p>\n<pre><code class=\"language-javascript\">Promise.all([act1(), act2(), act3()]).then(() =&gt; {\n  // all promises fulfilled!\n}).catch(err =&gt; {\n  // something went wrong!\n});\n</code></pre>\n<p>But how to run them sequentially? One way is to nest the promises:</p>\n<pre><code class=\"language-javascript\">act1().then(() =&gt; {\n  act2().then(() =&gt; {\n    act3().then(() =&gt; {\n      // all promises fulfilled!\n    });\n  });\n}).catch(err =&gt; {\n  // something went wrong!\n});\n</code></pre>\n<p>Nesting gets uglify real fast and some consider it an anti-pattern.</p>\n<p>My alternative method is to create an array of promise-returning functions and then use <code>Array.reduce</code> to run them one by one:</p>\n<pre><code class=\"language-javascript\">[act1, act2, act3].reduce(\n  (p, fn) =&gt; p.then(fn),\n  Promise.resolve()\n).then(() =&gt; {\n  // all promises fulfilled!\n}).catch(err =&gt; {\n  // something went wrong!\n});\n</code></pre>\n<p>If you’re not familiar with <a href=\"https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce\">reduce</a> it iterates over an array passing a value between each iteration. Usually you would concatenate a string or extend an object. In this example the value is the next promise. <code>Promise.resolve()</code> is used to start the chain.</p>\n<p>Seems like a cleaner solution than nesting?</p>\n<p>Here’s a CodePen:</p>\n<div class=\"b-post__image\">\n  <iframe height=\"265\" scrolling=\"no\" title=\"Resolve Promises sequentially without nesting\" src=\"//codepen.io/dbushell/embed/yVQKar/?height=150&theme-id=0&default-tab=js&embed-version=2\" frameborder=\"no\" allowtransparency=\"true\" allowfullscreen=\"true\">See the Pen <a href=\"https://codepen.io/dbushell/pen/yVQKar/\">Resolve Promises sequentially without nesting</a> by David Bushell (<a href=\"https://codepen.io/dbushell\">@dbushell</a>) on <a href=\"https://codepen.io\">CodePen</a>.</iframe>\n</div>\n\n\n<p><a href=\"https://twitter.com/i_like_robots\">Matt Hinchliffe</a> shared his library of <a href=\"https://www.npmjs.com/package/promise-patterns\">promise patterns</a> that includes a similar function. I’ve also been experimenting with JavaScript <a href=\"https://developer.mozilla.org/en/docs/Web/JavaScript/Guide/Iterators_and_Generators\">generators</a> and <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function\">async</a>/<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/await\">await</a>.</p>\n",
  "pageExcerpt": "JavaScript promises are a handy way to write asynchronous code. It’s common to have multiple promises resolve in parallel or series.\nLet’s say you have several functions that return a promise:\nfunction act1() {\n  return new Promise((resolve, reject) =&gt; {\n    // do something that might reject...\n    resolve();\n  });\n}\n\nIt’s easy […]",
  "pageTitle": "Working with Promises – David Bushell – Web Design (UK)"
}